# 摩尔投票法

###### 问：在重复的无序数组中寻找占比重占1/2以上的数字

方案1：O(n)->遍历计数

- > 直接暴力整个数组，给每个数字计数
  >
  > 计数完成后找到大于1/2比重的

- 该方案空间复杂度巨大



方案2：更小的O(n)->摩尔投票法

- > 遍历数组，每次取出**两个不同的数字**消除掉
  >
  > 最后剩下的一定是大于1/2比重的，如果数组最后为空，则没有大于1/2比重的数字

- 实现方法：

- - - 拥有一个**等栈**[^1]

    - 暴力从数组中取出一个数字

    - - 栈为空 or 与栈储值相等->推入
      - 否者 -> 同时推出一个栈元素与其一同消除

    - 最后栈中剩下的数字即为结果

- ```c++
  int solve(int a[],int n){
      int temp;
      int temp_size = 0;
      
      for(int i=0;i<n;i++){
          if(temp_size==0||temp==a[i]){
              temp = a[i];
              temp_size++;
          }
          else temp_size--;
      }
      return temp;
  }
  ```





######  1/n的摩尔投票法：在同条件的数组中找到超过1/n的数

> **最多可以有n-1个数字可以大于1/n**
>
> 与1/2思路相同，同时取出n个数字消除，最后剩下的就是答案

实现方法：

* 创建n个等栈
* 暴力取出一个数组中的数字
  * 有与数字相等的栈值 or 存在空栈
    * 推入数字
  * 否者从所有栈中均取出一个数字与该数字一同消除
* 最后剩下的非空栈值即为所求



---

[^1]:等栈：只存储一种数字的栈，实现：{值(int),size(int)}